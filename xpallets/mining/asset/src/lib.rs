// Copyright 2019-2022 ChainX Project Authors. Licensed under GPL-3.0.

//! # Asset Mining Module

#![cfg_attr(not(feature = "std"), no_std)]
#![allow(clippy::type_complexity)]

mod impls;
mod rpc;
mod types;
pub mod weights;

#[cfg(any(feature = "runtime-benchmarks", test))]
mod benchmarking;
#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;

use sp_std::prelude::*;

use frame_support::{
    dispatch::{DispatchError, DispatchResult},
    ensure,
    log::warn,
    traits::{Currency, ExistenceRequirement},
};
use frame_system::{ensure_root, ensure_signed};
use sp_runtime::traits::{SaturatedConversion, Zero};

use chainx_primitives::AssetId;
use xp_mining_common::{
    Claim, ComputeMiningWeight, MiningWeight as _, RewardPotAccountFor, WeightType,
    ZeroMiningWeightError,
};
use xpallet_assets::{AssetType, BalanceOf};
use xpallet_support::traits::TreasuryAccount;

pub use self::impls::SimpleAssetRewardPotAccountDeterminer;
pub use self::rpc::*;
pub use self::types::*;
pub use self::weights::WeightInfo;

pub use pallet::*;

#[frame_support::pallet]
pub mod pallet {
    use super::*;
    use frame_support::{dispatch::DispatchResult, pallet_prelude::*};
    use frame_system::pallet_prelude::*;

    #[pallet::config]
    pub trait Config: frame_system::Config + xpallet_assets::Config {
        /// The overarching event type.
        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;

        /// Get the staked balances of asset miner.
        type StakingInterface: StakingInterface<Self::AccountId, u128>;

        /// Get the possible referral of asset miner.
        type GatewayInterface: GatewayInterface<Self::AccountId>;

        /// Get the treasury account.
        type TreasuryAccount: TreasuryAccount<Self::AccountId>;

        /// Generate the reward pot account for mining asset.
        type DetermineRewardPotAccount: RewardPotAccountFor<Self::AccountId, AssetId>;

        type WeightInfo: WeightInfo;
    }

    #[pallet::pallet]
    #[pallet::generate_store(pub(super) trait Store)]
    pub struct Pallet<T>(PhantomData<T>);

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        /// Claims the staking reward given the `target` validator.
        #[pallet::weight(<T as Config>::WeightInfo::claim())]
        pub fn claim(origin: OriginFor<T>, #[pallet::compact] target: AssetId) -> DispatchResult {
            let sender = ensure_signed(origin)?;

            ensure!(
                Self::mining_previleged_assets().contains(&target),
                Error::<T>::NotPrevilegedAsset
            );

            <Self as Claim<T::AccountId>>::claim(&sender, &target)?;

            Ok(())
        }

        #[pallet::weight(<T as Config>::WeightInfo::set_claim_staking_requirement())]
        pub fn set_claim_staking_requirement(
            origin: OriginFor<T>,
            #[pallet::compact] asset_id: AssetId,
            #[pallet::compact] new: StakingRequirement,
        ) -> DispatchResult {
            ensure_root(origin)?;
            ClaimRestrictionOf::<T>::mutate(asset_id, |restriction| {
                restriction.staking_requirement = new;
            });
            Ok(())
        }

        #[pallet::weight(<T as Config>::WeightInfo::set_claim_frequency_limit())]
        pub fn set_claim_frequency_limit(
            origin: OriginFor<T>,
            #[pallet::compact] asset_id: AssetId,
            #[pallet::compact] new: T::BlockNumber,
        ) -> DispatchResult {
            ensure_root(origin)?;
            ClaimRestrictionOf::<T>::mutate(asset_id, |restriction| {
                restriction.frequency_limit = new;
            });
            Ok(())
        }

        #[pallet::weight(<T as Config>::WeightInfo::set_asset_power())]
        pub fn set_asset_power(
            origin: OriginFor<T>,
            #[pallet::compact] asset_id: AssetId,
            #[pallet::compact] new: FixedAssetPower,
        ) -> DispatchResult {
            ensure_root(origin)?;
            FixedAssetPowerOf::<T>::insert(asset_id, new);
            Ok(())
        }
    }

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// An asset miner claimed the mining reward. [claimer, asset_id, amount]
        Claimed(T::AccountId, AssetId, BalanceOf<T>),
        /// Issue new balance to the reward pot. [reward_pot_account, amount]
        Minted(T::AccountId, BalanceOf<T>),
    }

    /// Old name generated by `decl_event`.
    #[deprecated(note = "use `Event` instead")]
    pub type RawEvent<T> = Event<T>;

    /// Error for the staking module.
    #[pallet::error]
    pub enum Error<T> {
        /// The asset does not have the mining rights.
        NotPrevilegedAsset,
        /// Claimer does not have enough Staking locked balance.
        InsufficientStaking,
        /// Claimer just did a claim recently, the next frequency limit is not expired.
        UnexpiredFrequencyLimit,
        /// Zero mining weight.
        ZeroMiningWeight,
        /// Balances error.
        DispatchError,
    }

    #[pallet::type_value]
    pub fn DefaultForDepositReward<T: Config>() -> BalanceOf<T> {
        100_000u32.into()
    }

    /// Possible reward for the new asset owners that does not have native coins yet.
    #[pallet::storage]
    #[pallet::getter(fn deposit_reward)]
    pub type DepositReward<T: Config> =
        StorageValue<_, BalanceOf<T>, ValueQuery, DefaultForDepositReward<T>>;

    /// Can not claim if the claimer violates the restriction.
    #[pallet::storage]
    #[pallet::getter(fn claim_restriction_of)]
    pub type ClaimRestrictionOf<T: Config> =
        StorageMap<_, Twox64Concat, AssetId, ClaimRestriction<T::BlockNumber>, ValueQuery>;

    /// External Assets that have the mining rights.
    #[pallet::storage]
    #[pallet::getter(fn mining_previleged_assets)]
    pub type MiningPrevilegedAssets<T: Config> = StorageValue<_, Vec<AssetId>, ValueQuery>;

    /// Mining weight information of the mining assets.
    #[pallet::storage]
    #[pallet::getter(fn asset_ledgers)]
    pub type AssetLedgers<T: Config> =
        StorageMap<_, Twox64Concat, AssetId, AssetLedger<MiningWeight, T::BlockNumber>, ValueQuery>;

    /// The map from nominator to the vote weight ledger of all mining assets.
    #[pallet::storage]
    #[pallet::getter(fn miner_ledgers)]
    pub type MinerLedgers<T: Config> = StorageDoubleMap<
        _,
        Twox64Concat,
        T::AccountId,
        Twox64Concat,
        AssetId,
        MinerLedger<MiningWeight, T::BlockNumber>,
        ValueQuery,
    >;

    /// Mining power map of X-type assets.
    #[pallet::storage]
    #[pallet::getter(fn fixed_asset_power_of)]
    pub type FixedAssetPowerOf<T: Config> =
        StorageMap<_, Twox64Concat, AssetId, FixedAssetPower, ValueQuery>;

    #[pallet::genesis_config]
    pub struct GenesisConfig<T: Config> {
        pub claim_restrictions: Vec<(AssetId, (StakingRequirement, T::BlockNumber))>,
        pub mining_power_map: Vec<(AssetId, FixedAssetPower)>,
    }

    #[cfg(feature = "std")]
    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            Self {
                claim_restrictions: Default::default(),
                mining_power_map: Default::default(),
            }
        }
    }

    #[pallet::genesis_build]
    impl<T: Config> GenesisBuild<T> for GenesisConfig<T> {
        fn build(&self) {
            let extra_genesis_builder: fn(&Self) = |config| {
                for (asset_id, (staking_requirement, frequency_limit)) in &config.claim_restrictions
                {
                    ClaimRestrictionOf::<T>::insert(
                        asset_id,
                        ClaimRestriction {
                            staking_requirement: *staking_requirement,
                            frequency_limit: *frequency_limit,
                        },
                    );
                }
                for (asset_id, fixed_power) in &config.mining_power_map {
                    FixedAssetPowerOf::<T>::insert(asset_id, fixed_power);
                }
            };
            extra_genesis_builder(self);
        }
    }

    pub trait StakingInterface<AccountId, Balance> {
        /// Returns the amount of `who`s locked balances in Staking.
        fn staked_of(who: &AccountId) -> Balance;
    }

    impl<AccountId, Balance: Default> StakingInterface<AccountId, Balance> for () {
        fn staked_of(_: &AccountId) -> Balance {
            Default::default()
        }
    }

    impl<T: Config> StakingInterface<<T as frame_system::Config>::AccountId, u128> for T
    where
        T: xpallet_mining_staking::Config,
    {
        fn staked_of(who: &<T as frame_system::Config>::AccountId) -> u128 {
            xpallet_mining_staking::Pallet::<T>::staked_of(who).saturated_into()
        }
    }

    pub trait GatewayInterface<AccountId> {
        /// Returns the potential referral of `who` for `asset_id`.
        fn referral_of(who: &AccountId, asset_id: AssetId) -> Option<AccountId>;
    }

    impl<AccountId> GatewayInterface<AccountId> for () {
        fn referral_of(_: &AccountId, _: AssetId) -> Option<AccountId> {
            None
        }
    }

    impl<T: Config> From<ZeroMiningWeightError> for Error<T> {
        fn from(_: ZeroMiningWeightError) -> Self {
            Self::ZeroMiningWeight
        }
    }

    impl<T: Config> From<DispatchError> for Error<T> {
        fn from(_: DispatchError) -> Self {
            Self::DispatchError
        }
    }
}

impl<T: Config> Pallet<T> {
    #[inline]
    fn last_claim(who: &T::AccountId, asset_id: &AssetId) -> Option<T::BlockNumber> {
        MinerLedgers::<T>::get(who, asset_id).last_claim
    }

    #[inline]
    fn free_balance(who: &T::AccountId) -> BalanceOf<T> {
        <T as xpallet_assets::Config>::Currency::free_balance(who)
    }

    #[inline]
    fn transfer(from: &T::AccountId, to: &T::AccountId, value: BalanceOf<T>) -> DispatchResult {
        <T as xpallet_assets::Config>::Currency::transfer(
            from,
            to,
            value,
            ExistenceRequirement::KeepAlive,
        )
    }

    /// Returns the associated reward pot account for the given validator.
    #[inline]
    pub fn reward_pot_for(asset_id: &AssetId) -> T::AccountId {
        T::DetermineRewardPotAccount::reward_pot_account_for(asset_id)
    }

    /// This rule doesn't take effect if the interval is zero.
    fn passed_enough_interval(
        who: &T::AccountId,
        asset_id: &AssetId,
        frequency_limit: T::BlockNumber,
        current_block: T::BlockNumber,
    ) -> Result<(), Error<T>> {
        if !frequency_limit.is_zero() {
            if let Some(last_claim) = Self::last_claim(who, asset_id) {
                if current_block <= last_claim + frequency_limit {
                    warn!(
                        target: "runtime::mining::asset",
                        "{:?} can not claim until block {:?}",
                        who,
                        last_claim + frequency_limit
                    );
                    return Err(Error::<T>::UnexpiredFrequencyLimit);
                }
            }
        }
        Ok(())
    }

    fn need_more_stake(
        who: &T::AccountId,
        total_dividend: BalanceOf<T>,
        staking_requirement: StakingRequirement,
    ) -> Option<BalanceOf<T>> {
        if !staking_requirement.is_zero() {
            let staking_locked =
                T::StakingInterface::staked_of(who).saturated_into::<BalanceOf<T>>();
            let required_stake =
                staking_requirement.saturated_into::<BalanceOf<T>>() * total_dividend;
            if staking_locked < required_stake {
                warn!(
                    target: "runtime::mining::asset",
                    "{:?}'s staked balance is not insufficient, total dividend: {:?}, staked: {:?}, required: {:?}",
                    who,
                    total_dividend,
                    staking_locked,
                    required_stake
                );
                return Some(required_stake - staking_locked);
            }
        }
        None
    }

    /// Returns Ok(_) if the claimer has enough staking locked balance regarding the `total_dividend`.
    ///
    /// This rule doesn't take effect if the staking requirement is zero.
    fn has_enough_staking(
        who: &T::AccountId,
        total_dividend: BalanceOf<T>,
        staking_requirement: StakingRequirement,
    ) -> Result<(), Error<T>> {
        match Self::need_more_stake(who, total_dividend, staking_requirement) {
            Some(_) => Err(Error::<T>::InsufficientStaking),
            None => Ok(()),
        }
    }

    fn init_receiver_mining_ledger(
        who: &T::AccountId,
        asset_id: &AssetId,
        current_block: T::BlockNumber,
    ) {
        if !MinerLedgers::<T>::contains_key(who, asset_id) {
            MinerLedgers::<T>::insert(
                who,
                asset_id,
                MinerLedger::<MiningWeight, T::BlockNumber> {
                    last_mining_weight_update: current_block,
                    ..Default::default()
                },
            );
        }
    }

    fn update_miner_mining_weight(
        from: &T::AccountId,
        target: &AssetId,
        current_block: T::BlockNumber,
    ) {
        let new_weight =
            <Self as ComputeMiningWeight<T::AccountId, T::BlockNumber>>::settle_claimer_weight(
                from,
                target,
                current_block,
            );
        Self::apply_update_miner_mining_weight(from, target, new_weight, current_block);
    }

    #[cfg(feature = "std")]
    pub fn force_set_asset_mining_weight(
        target: &AssetId,
        new_weight: WeightType,
        current_block: T::BlockNumber,
    ) {
        Self::apply_update_asset_mining_weight(target, new_weight, current_block);
    }

    #[cfg(feature = "std")]
    pub fn force_set_miner_mining_weight(
        from: &T::AccountId,
        target: &AssetId,
        new_weight: WeightType,
        current_block: T::BlockNumber,
    ) {
        Self::apply_update_miner_mining_weight(from, target, new_weight, current_block);
    }

    fn apply_update_miner_mining_weight(
        from: &T::AccountId,
        target: &AssetId,
        new_weight: WeightType,
        current_block: T::BlockNumber,
    ) {
        let mut inner = MinerLedgers::<T>::get(from, target);
        let mut wrapper = MinerLedgerWrapper::<T>::new(from, target, &mut inner);
        wrapper.set_state_weight(new_weight, current_block);
        MinerLedgers::<T>::insert(from, target, inner);
    }

    fn update_asset_mining_weight(target: &AssetId, current_block: T::BlockNumber) {
        let new_weight =
            <Self as ComputeMiningWeight<T::AccountId, T::BlockNumber>>::settle_claimee_weight(
                target,
                current_block,
            );
        Self::apply_update_asset_mining_weight(target, new_weight, current_block);
    }

    fn apply_update_asset_mining_weight(
        target: &AssetId,
        new_weight: WeightType,
        current_block: T::BlockNumber,
    ) {
        let mut inner = AssetLedgers::<T>::get(target);
        let mut wrapper = AssetLedgerWrapper::<T>::new(target, &mut inner);
        wrapper.set_state_weight(new_weight, current_block);
        AssetLedgers::<T>::insert(target, inner);
    }

    fn update_mining_weights(
        source: &T::AccountId,
        target: &AssetId,
        current_block: T::BlockNumber,
    ) {
        Self::update_miner_mining_weight(source, target, current_block);
        Self::update_asset_mining_weight(target, current_block);
    }

    /// Gives a tiny reward to the depositor in case of it
    /// does not have enough balances to claim the mining reward.
    fn issue_deposit_reward(depositor: &T::AccountId, target: &AssetId) -> DispatchResult {
        let deposit_reward = Self::deposit_reward();
        let reward_pot = T::DetermineRewardPotAccount::reward_pot_account_for(target);
        let reward_pot_balance = Self::free_balance(&reward_pot);
        if reward_pot_balance >= deposit_reward && Self::free_balance(depositor) <= deposit_reward {
            Self::transfer(&reward_pot, depositor, deposit_reward)?;
        } else {
            warn!(
                target: "runtime::mining::asset",
                "asset {}'s reward pot has only {:?}, skipped issuing deposit reward for depositor {:?}",
                target,
                reward_pot_balance,
                depositor
            );
        }
        Ok(())
    }
}
