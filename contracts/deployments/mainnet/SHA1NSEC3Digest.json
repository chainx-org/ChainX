{
  "address": "0x849851A7683cfF52De5F50C712C0606FEf6A3e8f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "salt",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "iterations",
          "type": "uint256"
        }
      ],
      "name": "hash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e9806d0963233a2ceec08d32665ad9be97ef45c029d597480e37bdfc2055fa5",
  "receipt": {
    "to": null,
    "from": "0x0904Dac3347eA47d208F3Fd67402D039a3b99859",
    "contractAddress": "0x849851A7683cfF52De5F50C712C0606FEf6A3e8f",
    "transactionIndex": 205,
    "gasUsed": "787577",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9c6177045dd2ed0091f2cf71227577a203e763e795d76fc4c61ffe983a9f57c9",
    "transactionHash": "0x1e9806d0963233a2ceec08d32665ad9be97ef45c029d597480e37bdfc2055fa5",
    "logs": [],
    "blockNumber": 13040273,
    "cumulativeGasUsed": "16286139",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "40ce5451dce8f428cafdaca8fb82d91d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"salt\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"}],\"name\":\"hash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the DNSSEC iterated SHA1 digest used for NSEC3 records.\",\"kind\":\"dev\",\"methods\":{\"hash(bytes,bytes,uint256)\":{\"details\":\"Performs an NSEC3 iterated hash.\",\"params\":{\"data\":\"The data to hash.\",\"iterations\":\"The number of iterations to perform.\",\"salt\":\"The salt value to use on each iteration.\"},\"returns\":{\"_0\":\"The result of the iterated hash operation.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/nsec3digests/SHA1NSEC3Digest.sol\":\"SHA1NSEC3Digest\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The start offset to write to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write the byte at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\\n        if (off >= buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + off + len\\n                let dest := add(add(bufptr, off), len)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(add(off, len), mload(bufptr)) {\\n                    mstore(bufptr, add(off, len))\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (right-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        return writeInt(buf, buf.buf.length, data, len);\\n    }\\n}\\n\",\"keccak256\":\"0x18e42be1a3e4f7b4442d7ab0b524af5e09163503439954faf0ab3792cce91caa\"},\"contracts/dnssec-oracle/SHA1.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\nlibrary SHA1 {\\n    event Debug(bytes32 x);\\n\\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\\n        assembly {\\n            // Get a safe scratch location\\n            let scratch := mload(0x40)\\n\\n            // Get the data length, and point data at the first byte\\n            let len := mload(data)\\n            data := add(data, 32)\\n\\n            // Find the length after padding\\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\\n            switch lt(sub(totallen, len), 9)\\n            case 1 { totallen := add(totallen, 64) }\\n\\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\\n\\n            function readword(ptr, off, count) -> result {\\n                result := 0\\n                if lt(off, count) {\\n                    result := mload(add(ptr, off))\\n                    count := sub(count, off)\\n                    if lt(count, 32) {\\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\\n                        result := and(result, mask)\\n                    }\\n                }\\n            }\\n\\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\\n                mstore(scratch, readword(data, i, len))\\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\\n\\n                // If we loaded the last byte, store the terminator byte\\n                switch lt(sub(len, i), 64)\\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\\n\\n                // If this is the last block, store the length\\n                switch eq(i, sub(totallen, 64))\\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\\n\\n                // Expand the 16 32-bit words into 80\\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\\n                    mstore(add(scratch, j), temp)\\n                }\\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\\n                    mstore(add(scratch, j), temp)\\n                }\\n\\n                let x := h\\n                let f := 0\\n                let k := 0\\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\\n                    switch div(j, 20)\\n                    case 0 {\\n                        // f = d xor (b and (c xor d))\\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x5A827999\\n                    }\\n                    case 1{\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x6ED9EBA1\\n                    }\\n                    case 2 {\\n                        // f = (b and c) or (d and (b or c))\\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := and(div(x, 0x10000000000), f)\\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\\n                        k := 0x8F1BBCDC\\n                    }\\n                    case 3 {\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0xCA62C1D6\\n                    }\\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\\n                    temp := add(f, temp)\\n                    temp := add(and(x, 0xFFFFFFFF), temp)\\n                    temp := add(k, temp)\\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\\n                }\\n\\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\\n            }\\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\\n        }\\n    }\\n}\",\"keccak256\":\"0x43d6fc9dfba44bcc5d696ac24d8e1b90355942b41c8324ea31dce1ebfce82263\"},\"contracts/dnssec-oracle/nsec3digests/NSEC3Digest.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface for contracts that implement NSEC3 digest algorithms.\\n */\\ninterface NSEC3Digest {\\n    /**\\n     * @dev Performs an NSEC3 iterated hash.\\n     * @param salt The salt value to use on each iteration.\\n     * @param data The data to hash.\\n     * @param iterations The number of iterations to perform.\\n     * @return The result of the iterated hash operation.\\n     */\\n     function hash(bytes calldata salt, bytes calldata data, uint iterations) external virtual pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb3b61aee6bb472158b7ace6b5644dcb668271296b98a6dcde24dc72e3cdf4950\"},\"contracts/dnssec-oracle/nsec3digests/SHA1NSEC3Digest.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./NSEC3Digest.sol\\\";\\nimport \\\"../SHA1.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n/**\\n* @dev Implements the DNSSEC iterated SHA1 digest used for NSEC3 records.\\n*/\\ncontract SHA1NSEC3Digest is NSEC3Digest {\\n    using Buffer for Buffer.buffer;\\n\\n    function hash(bytes calldata salt, bytes calldata data, uint iterations) external override pure returns (bytes32) {\\n        Buffer.buffer memory buf;\\n        buf.init(salt.length + data.length + 16);\\n\\n        buf.append(data);\\n        buf.append(salt);\\n        bytes20 h = SHA1.sha1(buf.buf);\\n        if (iterations > 0) {\\n            buf.truncate();\\n            buf.appendBytes20(bytes20(0));\\n            buf.append(salt);\\n\\n            for (uint i = 0; i < iterations; i++) {\\n                buf.writeBytes20(0, h);\\n                h = SHA1.sha1(buf.buf);\\n            }\\n        }\\n\\n        return bytes32(h);\\n    }\\n}\\n\",\"keccak256\":\"0x2255d276d74fa236875f6cddd3061ce07189f84acd04538d002dbaa78daa48a0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610d61806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806368f9dab214610030575b600080fd5b61004a60048036038101906100459190610a91565b610060565b6040516100579190610b29565b60405180910390f35b600061006a610a18565b61009a601086869050898990506100819190610b44565b61008b9190610b44565b8261024290919063ffffffff16565b506100f285858080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050826102ac90919063ffffffff16565b5061014a87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050826102ac90919063ffffffff16565b50600061015a82600001516102ce565b905060008411156102255761016e826107ec565b50610186600060601b8361080390919063ffffffff16565b506101de88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050836102ac90919063ffffffff16565b5060005b8481101561022357610200600083856108349092919063ffffffff16565b5061020e83600001516102ce565b9150808061021b90610c3c565b9150506101e2565b505b806bffffffffffffffffffffffff19169250505095945050505050565b61024a610a18565b60006020836102599190610c85565b146102855760208261026b9190610c85565b60206102779190610bf4565b826102829190610b44565b91505b81836020018181525050604051808452600081528281016020016040525082905092915050565b6102b4610a18565b6102c683846000015151848551610861565b905092915050565b60006040518251602084019350604067ffffffffffffffc0600183011601600982820310600181146102ff57610306565b6040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f061035e565b6000838310156103575782820151905082840393506020841015610356576001846020036101000a03198082169150505b5b9392505050565b60005b8281101561076c57610374848289610325565b8552610384846020830189610325565b60208601526040818503106001811461039c576103a5565b60808286038701535b50604083038114600181146103b9576103c9565b6008850260208701511760208701525b5060405b60808110156104555760408103860151603882038701511860208203870151600c830388015118187c010000000100000001000000010000000100000001000000010000000163800000008204167ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe6002830216179050808288015250600c810190506103cd565b5060805b6101408110156104e257608081038601516070820387015118604082038701516018830388015118187c030000000300000003000000030000000300000003000000030000000363400000008204167ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc6004830216179050808288015250601881019050610459565b508160008060005b605081101561073e57601481046000811461051c576001811461056657600281146105a357600381146106065761063f565b6501000000000085046a01000000000000000000008604189350836f01000000000000000000000000000000860416935083650100000000008604189350635a827999925061063f565b6a010000000000000000000085046f01000000000000000000000000000000860418935083650100000000008604189350636ed9eba1925061063f565b6a010000000000000000000085046f01000000000000000000000000000000860417935083650100000000008604169350836a010000000000000000000086046f01000000000000000000000000000000870416179350638f1bbcdc925061063f565b6a010000000000000000000085046f0100000000000000000000000000000086041893508365010000000000860418935063ca62c1d692505b50601f770800000000000000000000000000000000000000000000008504168063ffffffe073080000000000000000000000000000000000000087041617905080840190508063ffffffff86160190508083019050807c0100000000000000000000000000000000000000000000000000000000600484028c0151040190507401000000000000000000000000000000000000000081026501000000000086041794506a0100000000000000000000633fffffff6a040000000000000000000087041663c00000006604000000000000880416170277ffffffff00ffffffff000000000000ffffffff00ffffffff8616179450506001810190506104ea565b5077ffffffff00ffffffff00ffffffff00ffffffff00ffffffff838601169450505050604081019050610361565b506c0100000000000000000000000063ffffffff821667ffffffff000000006101008404166bffffffff0000000000000000620100008504166fffffffff000000000000000000000000630100000086041673ffffffff000000000000000000000000000000006401000000008704161717171702945050505050919050565b6107f4610a18565b81516000815250819050919050565b61080b610a18565b61082c83846000015151846bffffffffffffffffffffffff19166014610950565b905092915050565b61083c610a18565b6108588484846bffffffffffffffffffffffff19166014610950565b90509392505050565b610869610a18565b825182111561087757600080fd5b846020015182856108889190610b44565b11156108bd576108bc8560026108ad886020015188876108a89190610b44565b6109d8565b6108b79190610b9a565b6109f4565b5b6000808651805187602083010193508088870111156108dc5787860182525b60208701925050505b6020841061092357805182526020826108fe9190610b44565b915060208161090d9190610b44565b905060208461091c9190610bf4565b93506108e5565b60006001856020036101000a03905080198251168184511681811785525050508692505050949350505050565b610958610a18565b846020015184836109699190610b44565b11156109915761099085600286856109819190610b44565b61098b9190610b9a565b6109f4565b5b60006001836101000a0390508260200360080284901c935085518386820101858319825116178152815185880111156109ca5784870182525b505050849050949350505050565b6000818311156109ea578290506109ee565b8190505b92915050565b600082600001519050610a078383610242565b50610a1283826102ac565b50505050565b604051806040016040528060608152602001600081525090565b60008083601f840112610a4457600080fd5b8235905067ffffffffffffffff811115610a5d57600080fd5b602083019150836001820283011115610a7557600080fd5b9250929050565b600081359050610a8b81610d14565b92915050565b600080600080600060608688031215610aa957600080fd5b600086013567ffffffffffffffff811115610ac357600080fd5b610acf88828901610a32565b9550955050602086013567ffffffffffffffff811115610aee57600080fd5b610afa88828901610a32565b93509350506040610b0d88828901610a7c565b9150509295509295909350565b610b2381610c28565b82525050565b6000602082019050610b3e6000830184610b1a565b92915050565b6000610b4f82610c32565b9150610b5a83610c32565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610b8f57610b8e610cb6565b5b828201905092915050565b6000610ba582610c32565b9150610bb083610c32565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610be957610be8610cb6565b5b828202905092915050565b6000610bff82610c32565b9150610c0a83610c32565b925082821015610c1d57610c1c610cb6565b5b828203905092915050565b6000819050919050565b6000819050919050565b6000610c4782610c32565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610c7a57610c79610cb6565b5b600182019050919050565b6000610c9082610c32565b9150610c9b83610c32565b925082610cab57610caa610ce5565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b610d1d81610c32565b8114610d2857600080fd5b5056fea264697066735822122014909039cf171591f8629bfc52114a9908cd2479bcd90c7bef5c7a119ab14a3264736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c806368f9dab214610030575b600080fd5b61004a60048036038101906100459190610a91565b610060565b6040516100579190610b29565b60405180910390f35b600061006a610a18565b61009a601086869050898990506100819190610b44565b61008b9190610b44565b8261024290919063ffffffff16565b506100f285858080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050826102ac90919063ffffffff16565b5061014a87878080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050826102ac90919063ffffffff16565b50600061015a82600001516102ce565b905060008411156102255761016e826107ec565b50610186600060601b8361080390919063ffffffff16565b506101de88888080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050836102ac90919063ffffffff16565b5060005b8481101561022357610200600083856108349092919063ffffffff16565b5061020e83600001516102ce565b9150808061021b90610c3c565b9150506101e2565b505b806bffffffffffffffffffffffff19169250505095945050505050565b61024a610a18565b60006020836102599190610c85565b146102855760208261026b9190610c85565b60206102779190610bf4565b826102829190610b44565b91505b81836020018181525050604051808452600081528281016020016040525082905092915050565b6102b4610a18565b6102c683846000015151848551610861565b905092915050565b60006040518251602084019350604067ffffffffffffffc0600183011601600982820310600181146102ff57610306565b6040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f061035e565b6000838310156103575782820151905082840393506020841015610356576001846020036101000a03198082169150505b5b9392505050565b60005b8281101561076c57610374848289610325565b8552610384846020830189610325565b60208601526040818503106001811461039c576103a5565b60808286038701535b50604083038114600181146103b9576103c9565b6008850260208701511760208701525b5060405b60808110156104555760408103860151603882038701511860208203870151600c830388015118187c010000000100000001000000010000000100000001000000010000000163800000008204167ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe6002830216179050808288015250600c810190506103cd565b5060805b6101408110156104e257608081038601516070820387015118604082038701516018830388015118187c030000000300000003000000030000000300000003000000030000000363400000008204167ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc6004830216179050808288015250601881019050610459565b508160008060005b605081101561073e57601481046000811461051c576001811461056657600281146105a357600381146106065761063f565b6501000000000085046a01000000000000000000008604189350836f01000000000000000000000000000000860416935083650100000000008604189350635a827999925061063f565b6a010000000000000000000085046f01000000000000000000000000000000860418935083650100000000008604189350636ed9eba1925061063f565b6a010000000000000000000085046f01000000000000000000000000000000860417935083650100000000008604169350836a010000000000000000000086046f01000000000000000000000000000000870416179350638f1bbcdc925061063f565b6a010000000000000000000085046f0100000000000000000000000000000086041893508365010000000000860418935063ca62c1d692505b50601f770800000000000000000000000000000000000000000000008504168063ffffffe073080000000000000000000000000000000000000087041617905080840190508063ffffffff86160190508083019050807c0100000000000000000000000000000000000000000000000000000000600484028c0151040190507401000000000000000000000000000000000000000081026501000000000086041794506a0100000000000000000000633fffffff6a040000000000000000000087041663c00000006604000000000000880416170277ffffffff00ffffffff000000000000ffffffff00ffffffff8616179450506001810190506104ea565b5077ffffffff00ffffffff00ffffffff00ffffffff00ffffffff838601169450505050604081019050610361565b506c0100000000000000000000000063ffffffff821667ffffffff000000006101008404166bffffffff0000000000000000620100008504166fffffffff000000000000000000000000630100000086041673ffffffff000000000000000000000000000000006401000000008704161717171702945050505050919050565b6107f4610a18565b81516000815250819050919050565b61080b610a18565b61082c83846000015151846bffffffffffffffffffffffff19166014610950565b905092915050565b61083c610a18565b6108588484846bffffffffffffffffffffffff19166014610950565b90509392505050565b610869610a18565b825182111561087757600080fd5b846020015182856108889190610b44565b11156108bd576108bc8560026108ad886020015188876108a89190610b44565b6109d8565b6108b79190610b9a565b6109f4565b5b6000808651805187602083010193508088870111156108dc5787860182525b60208701925050505b6020841061092357805182526020826108fe9190610b44565b915060208161090d9190610b44565b905060208461091c9190610bf4565b93506108e5565b60006001856020036101000a03905080198251168184511681811785525050508692505050949350505050565b610958610a18565b846020015184836109699190610b44565b11156109915761099085600286856109819190610b44565b61098b9190610b9a565b6109f4565b5b60006001836101000a0390508260200360080284901c935085518386820101858319825116178152815185880111156109ca5784870182525b505050849050949350505050565b6000818311156109ea578290506109ee565b8190505b92915050565b600082600001519050610a078383610242565b50610a1283826102ac565b50505050565b604051806040016040528060608152602001600081525090565b60008083601f840112610a4457600080fd5b8235905067ffffffffffffffff811115610a5d57600080fd5b602083019150836001820283011115610a7557600080fd5b9250929050565b600081359050610a8b81610d14565b92915050565b600080600080600060608688031215610aa957600080fd5b600086013567ffffffffffffffff811115610ac357600080fd5b610acf88828901610a32565b9550955050602086013567ffffffffffffffff811115610aee57600080fd5b610afa88828901610a32565b93509350506040610b0d88828901610a7c565b9150509295509295909350565b610b2381610c28565b82525050565b6000602082019050610b3e6000830184610b1a565b92915050565b6000610b4f82610c32565b9150610b5a83610c32565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115610b8f57610b8e610cb6565b5b828201905092915050565b6000610ba582610c32565b9150610bb083610c32565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615610be957610be8610cb6565b5b828202905092915050565b6000610bff82610c32565b9150610c0a83610c32565b925082821015610c1d57610c1c610cb6565b5b828203905092915050565b6000819050919050565b6000819050919050565b6000610c4782610c32565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610c7a57610c79610cb6565b5b600182019050919050565b6000610c9082610c32565b9150610c9b83610c32565b925082610cab57610caa610ce5565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b610d1d81610c32565b8114610d2857600080fd5b5056fea264697066735822122014909039cf171591f8629bfc52114a9908cd2479bcd90c7bef5c7a119ab14a3264736f6c63430008040033",
  "devdoc": {
    "details": "Implements the DNSSEC iterated SHA1 digest used for NSEC3 records.",
    "kind": "dev",
    "methods": {
      "hash(bytes,bytes,uint256)": {
        "details": "Performs an NSEC3 iterated hash.",
        "params": {
          "data": "The data to hash.",
          "iterations": "The number of iterations to perform.",
          "salt": "The salt value to use on each iteration."
        },
        "returns": {
          "_0": "The result of the iterated hash operation."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}