{
  "address": "0xca725080d594e225b5afb5d1f755aab36bfbbccf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "sig",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc019a62401b8ed32f6195bf3a90c2718da9ef1648286b21990b99580a2116d08",
  "receipt": {
    "to": null,
    "from": "0xa303ddc620aa7d1390baccc8a495508b183fab59",
    "contractAddress": "0xca725080d594e225b5afb5d1f755aab36bfbbccf",
    "transactionIndex": "0x2a",
    "gasUsed": "0x9c369",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8d3ed903701789c20998a16c01e9ff5de6dd3c8c9d89c8124c7e8362f972d3e0",
    "transactionHash": "0xc019a62401b8ed32f6195bf3a90c2718da9ef1648286b21990b99580a2116d08",
    "logs": [],
    "blockNumber": "0xa27159",
    "cumulativeGasUsed": "0x6728ea",
    "status": "0x1"
  },
  "args": [],
  "solcInputHash": "424cfdf012b9aa11d2e839569d49524c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the DNSSEC RSASHA256 algorithm.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/algorithms/RSASHA256Algorithm.sol\":\"RSASHA256Algorithm\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary BytesUtils {\\n    /*\\n    * @dev Returns the keccak-256 hash of a byte range.\\n    * @param self The byte string to hash.\\n    * @param offset The position to start hashing at.\\n    * @param len The number of bytes to hash.\\n    * @return The hash of the byte range.\\n    */\\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal.\\n    * @param self The first bytes to compare.\\n    * @param other The second bytes to compare.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\\n        return compare(self, 0, self.length, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal. Comparison is done per-rune,\\n    *      on unicode codepoints.\\n    * @param self The first bytes to compare.\\n    * @param offset The offset of self.\\n    * @param len    The length of self.\\n    * @param other The second bytes to compare.\\n    * @param otheroffset The offset of the other string.\\n    * @param otherlen    The length of the other string.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\\n        uint shortest = len;\\n        if (otherlen < len)\\n        shortest = otherlen;\\n\\n        uint selfptr;\\n        uint otherptr;\\n\\n        assembly {\\n            selfptr := add(self, add(offset, 32))\\n            otherptr := add(other, add(otheroffset, 32))\\n        }\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint mask;\\n                if (shortest > 32) {\\n                    mask = type(uint256).max;\\n                } else {\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                int diff = int(a & mask) - int(b & mask);\\n                if (diff != 0)\\n                return diff;\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n\\n        return int(len) - int(otherlen);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @param len The number of bytes to compare\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal with offsets.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\\n    }\\n\\n    /*\\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\\n    *      they are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\\n    }\\n\\n    /*\\n    * @dev Returns the 8-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 8 bits of the string, interpreted as an integer.\\n    */\\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\\n        return uint8(self[idx]);\\n    }\\n\\n    /*\\n    * @dev Returns the 16-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 16 bits of the string, interpreted as an integer.\\n    */\\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\\n        require(idx + 2 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bits of the string, interpreted as an integer.\\n    */\\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\\n        require(idx + 4 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\\n        require(idx + 32 <= self.length);\\n        assembly {\\n            ret := mload(add(add(self, 32), idx))\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\\n        require(idx + 20 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the n byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes.\\n    * @param len The number of bytes.\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\\n        require(len <= 32);\\n        require(idx + len <= self.length);\\n        assembly {\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\n            ret := and(mload(add(add(self, 32), idx)),  mask)\\n        }\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n\\n    /*\\n    * @dev Copies a substring into a new byte string.\\n    * @param self The byte string to copy from.\\n    * @param offset The offset to start copying at.\\n    * @param len The number of bytes to copy.\\n    */\\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\\n        require(offset + len <= self.length);\\n\\n        bytes memory ret = new bytes(len);\\n        uint dest;\\n        uint src;\\n\\n        assembly {\\n            dest := add(ret, 32)\\n            src := add(add(self, 32), offset)\\n        }\\n        memcpy(dest, src, len);\\n\\n        return ret;\\n    }\\n\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\n    // 0xFF represents invalid characters in that range.\\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\\n\\n    /**\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\n     * @param self The data to decode.\\n     * @param off Offset into the string to start at.\\n     * @param len Number of characters to decode.\\n     * @return The decoded data, left aligned.\\n     */\\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\\n        require(len <= 52);\\n\\n        uint ret = 0;\\n        uint8 decoded;\\n        for(uint i = 0; i < len; i++) {\\n            bytes1 char = self[off + i];\\n            require(char >= 0x30 && char <= 0x7A);\\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\\n            require(decoded <= 0x20);\\n            if(i == len - 1) {\\n                break;\\n            }\\n            ret = (ret << 5) | decoded;\\n        }\\n\\n        uint bitlen = len * 5;\\n        if(len % 8 == 0) {\\n            // Multiple of 8 characters, no padding\\n            ret = (ret << 5) | decoded;\\n        } else if(len % 8 == 2) {\\n            // Two extra characters - 1 byte\\n            ret = (ret << 3) | (decoded >> 2);\\n            bitlen -= 2;\\n        } else if(len % 8 == 4) {\\n            // Four extra characters - 2 bytes\\n            ret = (ret << 1) | (decoded >> 4);\\n            bitlen -= 4;\\n        } else if(len % 8 == 5) {\\n            // Five extra characters - 3 bytes\\n            ret = (ret << 4) | (decoded >> 1);\\n            bitlen -= 1;\\n        } else if(len % 8 == 7) {\\n            // Seven extra characters - 4 bytes\\n            ret = (ret << 2) | (decoded >> 3);\\n            bitlen -= 3;\\n        } else {\\n            revert();\\n        }\\n\\n        return bytes32(ret << (256 - bitlen));\\n    }\\n}\",\"keccak256\":\"0x83315df2e54c74451577c70da2c267c3459802b08b9aeec6516302eee70f796e\"},\"contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\n*/\\ninterface Algorithm {\\n    /**\\n    * @dev Verifies a signature.\\n    * @param key The public key to verify with.\\n    * @param data The signed data to verify.\\n    * @param signature The signature to verify.\\n    * @return True iff the signature is valid.\\n    */\\n    function verify(bytes calldata key, bytes calldata data, bytes calldata signature) external virtual view returns (bool);\\n}\\n\",\"keccak256\":\"0x51d6251568844e435f58952354abe8c8c8e978ab40ecb0bbb2f5bd767838b3a7\"},\"contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary ModexpPrecompile {\\n    /**\\n    * @dev Computes (base ^ exponent) % modulus over big numbers.\\n    */\\n    function modexp(bytes memory base, bytes memory exponent, bytes memory modulus) internal view returns (bool success, bytes memory output) {\\n        bytes memory input = abi.encodePacked(\\n            uint256(base.length),\\n            uint256(exponent.length),\\n            uint256(modulus.length),\\n            base,\\n            exponent,\\n            modulus\\n        );\\n\\n        output = new bytes(modulus.length);\\n\\n        assembly {\\n            success := staticcall(gas(), 5, add(input, 32), mload(input), add(output, 32), mload(modulus))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe3d689d14cf0294f433f4e14cdd8feab8d542e5b8342c911d5c7cb518170e2b1\"},\"contracts/dnssec-oracle/algorithms/RSASHA256Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./Algorithm.sol\\\";\\nimport \\\"../BytesUtils.sol\\\";\\nimport \\\"./RSAVerify.sol\\\";\\n\\n/**\\n* @dev Implements the DNSSEC RSASHA256 algorithm.\\n*/\\ncontract RSASHA256Algorithm is Algorithm {\\n    using BytesUtils for *;\\n\\n    function verify(bytes calldata key, bytes calldata data, bytes calldata sig) external override view returns (bool) {\\n        bytes memory exponent;\\n        bytes memory modulus;\\n\\n        uint16 exponentLen = uint16(key.readUint8(4));\\n        if (exponentLen != 0) {\\n            exponent = key.substring(5, exponentLen);\\n            modulus = key.substring(exponentLen + 5, key.length - exponentLen - 5);\\n        } else {\\n            exponentLen = key.readUint16(5);\\n            exponent = key.substring(7, exponentLen);\\n            modulus = key.substring(exponentLen + 7, key.length - exponentLen - 7);\\n        }\\n\\n        // Recover the message from the signature\\n        bool ok;\\n        bytes memory result;\\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\\n\\n        // Verify it ends with the hash of our data\\n        return ok && sha256(data) == result.readBytes32(result.length - 32);\\n    }\\n}\\n\",\"keccak256\":\"0x8a5f89ac82a433590cd29d0a9e72ca68618b86105dfcd62e04dff313ddcf809d\"},\"contracts/dnssec-oracle/algorithms/RSAVerify.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"../BytesUtils.sol\\\";\\nimport \\\"./ModexpPrecompile.sol\\\";\\n\\nlibrary RSAVerify {\\n    /**\\n    * @dev Recovers the input data from an RSA signature, returning the result in S.\\n    * @param N The RSA public modulus.\\n    * @param E The RSA public exponent.\\n    * @param S The signature to recover.\\n    * @return True if the recovery succeeded.\\n    */\\n    function rsarecover(bytes memory N, bytes memory E, bytes memory S) internal view returns (bool, bytes memory) {\\n        return ModexpPrecompile.modexp(S, E, N);\\n    }\\n}\\n\",\"keccak256\":\"0xc630e4d296e2d7bd2b968f8a9a8df629fef5161e10ffae9973e045900741cfe4\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610aa3806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004a6004803603810190610045919061071d565b610060565b60405161005791906108ba565b60405180910390f35b600060608060006100bf60048b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506103ea90919063ffffffff16565b60ff16905060008161ffff16146101be5761012e60058261ffff168c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b92506101b760058261014091906108eb565b61ffff1660058361ffff168d8d90506101599190610979565b6101639190610979565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b9150610302565b61021660058b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506104f690919063ffffffff16565b905061027660078261ffff168c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b92506102ff60078261028891906108eb565b61ffff1660078361ffff168d8d90506102a19190610979565b6102ab9190610979565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b91505b6000606061035584868a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050610525565b80925081935050508180156103d95750610385602082516103769190610979565b8261054090919063ffffffff16565b60028b8b60405161039792919061083d565b602060405180830381855afa1580156103b4573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906103d791906106f4565b145b955050505050509695505050505050565b6000828281518110610425577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c905092915050565b60608351828461044b9190610923565b111561045657600080fd5b60008267ffffffffffffffff811115610498577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156104ca5781602001600182028036833780820191505090505b50905060008060208301915085602088010190506104e982828761056b565b8293505050509392505050565b600082516002836105079190610923565b111561051257600080fd5b61ffff8260028501015116905092915050565b600060606105348385876105cf565b91509150935093915050565b600082516020836105519190610923565b111561055c57600080fd5b81602084010151905092915050565b5b602081106105aa57815183526020836105859190610923565b92506020826105949190610923565b91506020816105a39190610979565b905061056c565b60006001826020036101000a0390508019835116818551168181178652505050505050565b6000606060008551855185518888886040516020016105f396959493929190610856565b6040516020818303038152906040529050835167ffffffffffffffff811115610645577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156106775781602001600182028036833780820191505090505b50915083516020830182516020840160055afa925050935093915050565b6000815190506106a481610a56565b92915050565b60008083601f8401126106bc57600080fd5b8235905067ffffffffffffffff8111156106d557600080fd5b6020830191508360018202830111156106ed57600080fd5b9250929050565b60006020828403121561070657600080fd5b600061071484828501610695565b91505092915050565b6000806000806000806060878903121561073657600080fd5b600087013567ffffffffffffffff81111561075057600080fd5b61075c89828a016106aa565b9650965050602087013567ffffffffffffffff81111561077b57600080fd5b61078789828a016106aa565b9450945050604087013567ffffffffffffffff8111156107a657600080fd5b6107b289828a016106aa565b92509250509295509295509295565b6107ca816109ad565b82525050565b60006107dc83856108e0565b93506107e98385846109db565b82840190509392505050565b6000610800826108d5565b61080a81856108e0565b935061081a8185602086016109ea565b80840191505092915050565b610837610832826109d1565b610a1d565b82525050565b600061084a8284866107d0565b91508190509392505050565b60006108628289610826565b6020820191506108728288610826565b6020820191506108828287610826565b60208201915061089282866107f5565b915061089e82856107f5565b91506108aa82846107f5565b9150819050979650505050505050565b60006020820190506108cf60008301846107c1565b92915050565b600081519050919050565b600081905092915050565b60006108f6826109c3565b9150610901836109c3565b92508261ffff0382111561091857610917610a27565b5b828201905092915050565b600061092e826109d1565b9150610939836109d1565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561096e5761096d610a27565b5b828201905092915050565b6000610984826109d1565b915061098f836109d1565b9250828210156109a2576109a1610a27565b5b828203905092915050565b60008115159050919050565b6000819050919050565b600061ffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015610a085780820151818401526020810190506109ed565b83811115610a17576000848401525b50505050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b610a5f816109b9565b8114610a6a57600080fd5b5056fea2646970667358221220e8a3623f1ae22c54b7f4fd48d3e69f062c1f2d47656ad9b51d4eac713b8fbde864736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004a6004803603810190610045919061071d565b610060565b60405161005791906108ba565b60405180910390f35b600060608060006100bf60048b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506103ea90919063ffffffff16565b60ff16905060008161ffff16146101be5761012e60058261ffff168c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b92506101b760058261014091906108eb565b61ffff1660058361ffff168d8d90506101599190610979565b6101639190610979565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b9150610302565b61021660058b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050506104f690919063ffffffff16565b905061027660078261ffff168c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b92506102ff60078261028891906108eb565b61ffff1660078361ffff168d8d90506102a19190610979565b6102ab9190610979565b8c8c8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505061043b9092919063ffffffff16565b91505b6000606061035584868a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f82011690508083019250505050505050610525565b80925081935050508180156103d95750610385602082516103769190610979565b8261054090919063ffffffff16565b60028b8b60405161039792919061083d565b602060405180830381855afa1580156103b4573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906103d791906106f4565b145b955050505050509695505050505050565b6000828281518110610425577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602001015160f81c60f81b60f81c905092915050565b60608351828461044b9190610923565b111561045657600080fd5b60008267ffffffffffffffff811115610498577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156104ca5781602001600182028036833780820191505090505b50905060008060208301915085602088010190506104e982828761056b565b8293505050509392505050565b600082516002836105079190610923565b111561051257600080fd5b61ffff8260028501015116905092915050565b600060606105348385876105cf565b91509150935093915050565b600082516020836105519190610923565b111561055c57600080fd5b81602084010151905092915050565b5b602081106105aa57815183526020836105859190610923565b92506020826105949190610923565b91506020816105a39190610979565b905061056c565b60006001826020036101000a0390508019835116818551168181178652505050505050565b6000606060008551855185518888886040516020016105f396959493929190610856565b6040516020818303038152906040529050835167ffffffffffffffff811115610645577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156106775781602001600182028036833780820191505090505b50915083516020830182516020840160055afa925050935093915050565b6000815190506106a481610a56565b92915050565b60008083601f8401126106bc57600080fd5b8235905067ffffffffffffffff8111156106d557600080fd5b6020830191508360018202830111156106ed57600080fd5b9250929050565b60006020828403121561070657600080fd5b600061071484828501610695565b91505092915050565b6000806000806000806060878903121561073657600080fd5b600087013567ffffffffffffffff81111561075057600080fd5b61075c89828a016106aa565b9650965050602087013567ffffffffffffffff81111561077b57600080fd5b61078789828a016106aa565b9450945050604087013567ffffffffffffffff8111156107a657600080fd5b6107b289828a016106aa565b92509250509295509295509295565b6107ca816109ad565b82525050565b60006107dc83856108e0565b93506107e98385846109db565b82840190509392505050565b6000610800826108d5565b61080a81856108e0565b935061081a8185602086016109ea565b80840191505092915050565b610837610832826109d1565b610a1d565b82525050565b600061084a8284866107d0565b91508190509392505050565b60006108628289610826565b6020820191506108728288610826565b6020820191506108828287610826565b60208201915061089282866107f5565b915061089e82856107f5565b91506108aa82846107f5565b9150819050979650505050505050565b60006020820190506108cf60008301846107c1565b92915050565b600081519050919050565b600081905092915050565b60006108f6826109c3565b9150610901836109c3565b92508261ffff0382111561091857610917610a27565b5b828201905092915050565b600061092e826109d1565b9150610939836109d1565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561096e5761096d610a27565b5b828201905092915050565b6000610984826109d1565b915061098f836109d1565b9250828210156109a2576109a1610a27565b5b828203905092915050565b60008115159050919050565b6000819050919050565b600061ffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015610a085780820151818401526020810190506109ed565b83811115610a17576000848401525b50505050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b610a5f816109b9565b8114610a6a57600080fd5b5056fea2646970667358221220e8a3623f1ae22c54b7f4fd48d3e69f062c1f2d47656ad9b51d4eac713b8fbde864736f6c63430008040033",
  "devdoc": {
    "details": "Implements the DNSSEC RSASHA256 algorithm.",
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}